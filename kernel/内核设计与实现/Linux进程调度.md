# Linux进程调度



## 进程分类

1、实时进程

2、普通进程



## 上下文切换

cpu上运行多个进程（采用分割时间片的方法）

p1 运行了50ms后运行 p2

p1的进程信息（PC，变量，程序运行位置，寄存器值，执行环境）保存在内核栈里

p2 加载并运行



## 调度算法

单个CPU一个进程 --》 多个进程

> 1、FIFO：先来先调度

P1 20ms P2 40ms P3 5ms 

eg: 

P1 1000ms P2需要长时间等待才能执行，如果是为实时响应的话会卡顿

劣势：需要长时间等待才能分到CPU

> 2、STF：谁的进程时间短，谁先被调度

P1 1000ms P2 40ms P3 5ms 

同时到达： P3->P2->P1

优势：整体等待时间下降

劣势：如果长时间的进程先到达，其他进程需要等待

> 3、STCF：谁先完成，谁先被调度（抢占式）

p1---10ms-->p2->p1->p3->p1

优势：后面来的进程可以抢占前面的进程，CPU先调度完成时间短的，再切换回去调度完成时间长的

劣势：完成时间长的进程响应时间长

> 4、RR轮询的方式

1s分为很多时间片，CPU把时间片分给每个进程



一个cpu 多个进程 放在哪？用什么数据结构存储？

## 进程队列

早期：多个cpu 放在全局队列，保证线程安全会加锁，释放锁，导致性能低

进展：局部队列

每个cpu有自己的进程队列，每个cpu在自己的队列中取进程执行



## 进程优先级

不是每个进程都有相同的优先级。

查看进程优先级 ps -l

![image-20210527230450709](C:\Users\z00585918\AppData\Roaming\Typora\typora-user-images\image-20210527230450709.png)

> nice值

进程nice值，对别的进程好的程度。

nice值越高，优先级越低，得到cpu调度的时间越少。

![image-20210527230756935](C:\Users\z00585918\AppData\Roaming\Typora\typora-user-images\image-20210527230756935.png)

renice：修改优先级

**优先级值越高，优先级越低**

eg：renice -n 修改后的nice值 -p PPID

> nice范围：-19到20 

用户可以设置的值，**静态优先级**

> 优先级范围：0到139



![image-20210527232016922](C:\Users\z00585918\AppData\Roaming\Typora\typora-user-images\image-20210527232016922.png)



实时进程的优先级是从0到100

普通进程的优先级：100-139



**动态优先级**：内核决定，有些进程会超时会受到惩罚， 内核会自动修改优先级，有些进程受到不公平，会调高优先级



## Linux调度器

cpu进程队列，队列里是带有优先级的进程

进程队列（链表实现的），找到优先级最高的进程，效率低  O(N)



O(1)调度器

位运算最快。0-139的范围。

优先级映射成bitmap

在优先级上面有进程，那么这个位置为1

![image-20210527232819637](C:\Users\z00585918\AppData\Roaming\Typora\typora-user-images\image-20210527232819637.png)

优先级0：p1和p2

优先级2：p3

先找到优先级0，先调度p1，后调度p2



active expire

两个队列会交换，指针交换

